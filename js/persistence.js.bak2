// Plik: js/persistence.js
// Cel: ZarzƒÖdza utrwalaniem stanu i eksportami - NAPRAWIONA WERSJA

import { getState, restoreState, resetState, state, getLogo, getEventHistory } from './state.js';
import { showNotification, showConfirmation, DOMElements, renderFinalSummary } from './ui.js';
import { clearHistory, saveToUndoHistory } from './history.js';
import * as CheckpointsDB from './checkpointsDb.js';
import * as Competition from './competition.js';

const AUTO_SAVE_KEY = 'strongmanState_autoSave_v12';
const THEME_KEY = 'strongmanTheme_v12';

let autoSaveTimer;

// === THEME MANAGEMENT ===
export function saveTheme(themeName) { 
    localStorage.setItem(THEME_KEY, themeName); 
}

export function loadTheme() { 
    return localStorage.getItem(THEME_KEY) || 'light'; 
}

// === AUTO-SAVE (NAPRAWIONE) ===
export function triggerAutoSave() {
    clearTimeout(autoSaveTimer);
    autoSaveTimer = setTimeout(() => {
        // POPRAWKA: Usuniƒôto sprawdzanie nieistniejƒÖcego mainContent
        // W nowym systemie aplikacja mo≈ºe dzia≈Çaƒá w r√≥≈ºnych widokach
        try {
            localStorage.setItem(AUTO_SAVE_KEY, JSON.stringify(getState()));
            const indicator = document.getElementById('saveIndicator');
            if (indicator) {
                indicator.classList.add('visible');
                setTimeout(() => indicator.classList.remove('visible'), 1500);
            }
        } catch(e) {
            showNotification("B≈ÇƒÖd auto-zapisu. Pamiƒôƒá mo≈ºe byƒá pe≈Çna.", "error");
        }
    }, 1000);
}

// === SESSION RESTORATION ===
export async function loadStateFromAutoSave() {
    const savedStateJSON = localStorage.getItem(AUTO_SAVE_KEY);
    if (!savedStateJSON) return false;

    if (await showConfirmation("Wykryto niezako≈ÑczonƒÖ sesjƒô. Czy chcesz jƒÖ przywr√≥ciƒá?")) {
        try {
            const loadedState = JSON.parse(savedStateJSON);
            restoreState(loadedState);
            showNotification("Sesja zosta≈Ça przywr√≥cona!", "success");
            return true;
        } catch (error) {
            showNotification("Plik auto-zapisu uszkodzony. Zostanie usuniƒôty.", "error");
            localStorage.removeItem(AUTO_SAVE_KEY);
            return false;
        }
    } else {
        localStorage.removeItem(AUTO_SAVE_KEY);
        return false;
    }
}

// === STATE EXPORT ===
export function exportStateToFile(isInitial = false) {
    const stateData = getState();
    const stateJson = JSON.stringify(stateData, null, 2);
    const blob = new Blob([stateJson], { type: 'application/json' });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    
    // POPRAWKA: Bezpieczne pobieranie warto≈õci p√≥l z fallbackami
    const eventNameInput = document.getElementById('eventNameInput');
    const eventLocationInput = document.getElementById('eventLocationInput');
    
    const eventName = (eventNameInput ? eventNameInput.value : stateData.eventName || 'zawody')
        .replace(/[\s\/]/g, '_');
    const location = (eventLocationInput ? eventLocationInput.value : stateData.eventLocation || 'lokalizacja')
        .replace(/[\s\/]/g, '_');
    const date = new Date().toISOString().slice(0, 10);
    
    let filename = `${location}_${eventName}_${date}`;
    if (isInitial) {
        filename += '_stan_poczatkowy.json';
    } else {
        filename += `_konkurencja_${state.eventNumber}.json`;
    }

    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(link.href);
    showNotification("Stan aplikacji zosta≈Ç wyeksportowany.", "success");
}

// === STATE IMPORT ===
export async function importStateFromFile(file) {
    return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                if (!importedData.competitors || !importedData.eventHistory) {
                    throw new Error("Plik nie wyglƒÖda na prawid≈Çowy plik stanu aplikacji.");
                }
                if (await showConfirmation("Czy na pewno chcesz importowaƒá stan z pliku? Spowoduje to nadpisanie bie≈ºƒÖcej sesji.")) {
                    restoreState(importedData);
                    clearHistory();
                    saveToUndoHistory(importedData);
                    showNotification("Stan pomy≈õlnie zaimportowano!", "success");
                    resolve(true);
                } else {
                    resolve(false);
                }
            } catch (error) {
                showNotification(`B≈ÇƒÖd: ${error.message}`, "error");
                resolve(false);
            }
        };
        reader.readAsText(file);
    });
}

// === APPLICATION RESET ===
export async function resetApplication() {
    if (await showConfirmation("Czy na pewno chcesz zresetowaƒá ca≈ÇƒÖ aplikacjƒô? Spowoduje to usuniƒôcie wszystkich danych, w tym punkt√≥w kontrolnych z bazy danych.")) {
        localStorage.removeItem(AUTO_SAVE_KEY);
        localStorage.removeItem(THEME_KEY);
        await CheckpointsDB.clearAllCheckpointsDB();
        resetState();
        showNotification("Aplikacja zosta≈Ça zresetowana.", "success");
        window.location.reload();
    }
}

// === CHECKPOINT MANAGEMENT ===
function getMinimalStateForCheckpoint() {
    const fullState = getState();
    return {
        competitors: fullState.competitors,
        scores: fullState.scores,
        eventNumber: fullState.eventNumber,
        eventHistory: fullState.eventHistory,
        logoData: fullState.logoData,
        currentEventType: fullState.currentEventType,
        eventName: fullState.eventName,
        eventLocation: fullState.eventLocation,
        eventDate: fullState.eventDate,
        eventTitle: fullState.eventTitle,
        currentTab: fullState.currentTab
    };
}

export async function saveCheckpoint() {
    const checkpointName = `Punkt z ${new Date().toLocaleString('pl-PL')}`;
    if (await showConfirmation(`Czy na pewno zapisaƒá punkt kontrolny "${checkpointName}"?`)) {
        const key = `checkpoint_${Date.now()}`;
        const data = {
            name: checkpointName,
            timestamp: new Date().toISOString(),
            state: getMinimalStateForCheckpoint()
        };
        try {
            await CheckpointsDB.saveCheckpointDB(key, data);
            showNotification(`Zapisano punkt kontrolny: "${checkpointName}"`, "success");
            // POPRAWKA: Od≈õwie≈º listƒô po zapisaniu
            handleShowCheckpoints(true);
            return true;
        } catch (e) {
            showNotification("WystƒÖpi≈Ç b≈ÇƒÖd podczas zapisu punktu kontrolnego.", "error");
            console.error("B≈ÇƒÖd zapisu checkpointu do IndexedDB:", e);
            return false;
        }
    }
    return false;
}

export async function handleShowCheckpoints(forceShow = false) {
    const container = DOMElements.checkpointList;
    const listContainer = DOMElements.checkpointListContainer;
    
    if (!container || !listContainer) {
        showNotification("B≈ÇƒÖd: nie mo≈ºna znale≈∫ƒá kontenera punkt√≥w kontrolnych.", "error");
        return;
    }
    
    try {
        const checkpoints = await CheckpointsDB.getCheckpointsDB();

        // Aktualizuj informacjƒô o u≈ºyciu pamiƒôci
        if (DOMElements.storageUsage) {
            DOMElements.storageUsage.textContent = `Zapisano: ${checkpoints.length} punkt√≥w`;
        }

        // Renderuj listƒô checkpoint√≥w
        if (checkpoints.length === 0) {
            container.innerHTML = `
                <div style="text-align:center; padding: 20px 0; color: #666;">
                    <p>Brak zapisanych punkt√≥w kontrolnych.</p>
                    <button id="closeCheckpointsBtn" class="btn btn-secondary" style="margin-top: 15px;">‚úï Zamknij</button>
                </div>
            `;
        } else {
            container.innerHTML = `
                <div class="history-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid #ddd;">
                    <h4 style="margin: 0;">Zapisane punkty kontrolne</h4>
                    <button id="closeCheckpointsBtn" class="close-btn" style="background: none; border: none; font-size: 20px; cursor: pointer; color: #666;">‚úï</button>
                </div>
                ${checkpoints.map(cp => `
                    <div class="checkpoint-item" style="display: flex; justify-content: space-between; align-items: center; padding: 12px; margin-bottom: 8px; border: 1px solid #ddd; border-radius: 4px; background: #f9f9f9;">
                        <div class="checkpoint-info" style="flex: 1;">
                            <button data-action="load-checkpoint" data-key="${cp.key}" class="checkpoint-load-btn" style="background: none; border: none; cursor: pointer; text-align: left; width: 100%; padding: 8px; font-weight: bold; color: #333; border-radius: 4px; transition: background 0.2s;">
                                <strong>${cp.name}</strong>
                                <br><small style="color: #666;">${new Date(cp.timestamp || cp.key.replace('checkpoint_', '')).toLocaleString('pl-PL')}</small>
                            </button>
                        </div>
                        <button class="delete-checkpoint-btn" data-action="delete-checkpoint" data-key="${cp.key}" title="Usu≈Ñ punkt kontrolny" style="background: #e74c3c; color: white; border: none; padding: 8px 12px; border-radius: 3px; cursor: pointer; margin-left: 10px; transition: background 0.2s;">
                            üóëÔ∏è
                        </button>
                    </div>
                `).join('')}
            `;
        }

        // POPRAWKA: Dodaj event listener dla przycisku zamknij
        const closeBtn = container.querySelector('#closeCheckpointsBtn');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                listContainer.style.display = 'none';
            });
        }
        
        if (forceShow) {
            listContainer.style.display = 'block';
        } else {
            const isVisible = listContainer.style.display === 'block';
            listContainer.style.display = isVisible ? 'none' : 'block';
        }
    } catch (error) {
        console.error('B≈ÇƒÖd ≈Çadowania checkpoint√≥w:', error);
        showNotification("B≈ÇƒÖd podczas ≈Çadowania punkt√≥w kontrolnych.", "error");
    }
}

// POPRAWKA: Ulepszona obs≈Çuga akcji checkpoint√≥w
export async function handleCheckpointListActions(e, refreshFullUICallback) {
    const button = e.target.closest('button');
    if (!button) return;

    const action = button.dataset.action;
    const key = button.dataset.key;

    if (action === 'load-checkpoint') {
        try {
            const checkpoints = await CheckpointsDB.getCheckpointsDB();
            const checkpointToLoad = checkpoints.find(cp => cp.key === key);
            
            if (checkpointToLoad && await showConfirmation(`Czy na pewno chcesz wczytaƒá punkt kontrolny "${checkpointToLoad.name}"? Obecny stan zostanie utracony.`)) {
                restoreState(checkpointToLoad.state);
                clearHistory();
                saveToUndoHistory(checkpointToLoad.state);
                
                // Zamknij panel checkpoint√≥w
                const listContainer = DOMElements.checkpointListContainer;
                if (listContainer) {
                    listContainer.style.display = 'none';
                }
                
                // Od≈õwie≈º UI
                if (refreshFullUICallback) {
                    refreshFullUICallback();
                }
                
                showNotification("Punkt kontrolny zosta≈Ç wczytany.", "success");
            }
        } catch (error) {
            console.error('B≈ÇƒÖd ≈Çadowania checkpointu:', error);
            showNotification("B≈ÇƒÖd podczas ≈Çadowania punktu kontrolnego.", "error");
        }
    } else if (action === 'delete-checkpoint') {
        if (await showConfirmation(`Czy na pewno chcesz trwale usunƒÖƒá ten punkt kontrolny?`)) {
            try {
                await CheckpointsDB.deleteCheckpointDB(key);
                showNotification("Punkt kontrolny usuniƒôty.", "success");
                handleShowCheckpoints(true); // Od≈õwie≈º listƒô
            } catch (error) {
                console.error('B≈ÇƒÖd usuwania checkpointu:', error);
                showNotification("B≈ÇƒÖd podczas usuwania punktu kontrolnego.", "error");
            }
        }
    }
}

// POPRAWKA: Funkcja przeliczania po edycji wynik√≥w
export async function recalculateAfterEdit(eventId, newResults) {
    try {
        const currentState = getState();
        const eventToEdit = currentState.eventHistory.find(e => e.nr === eventId);
        
        if (!eventToEdit) {
            throw new Error("Nie mo≈ºna znale≈∫ƒá konkurencji do edycji");
        }
        
        // Przygotuj dane do przeliczenia
        const resultsForCalculation = newResults.map(result => ({
            name: result.name,
            result: result.result
        }));
        
        // Przelicz punkty u≈ºywajƒÖc istniejƒÖcej funkcji
        const totalCompetitors = currentState.competitors.length;
        const { results, error } = Competition.calculateEventPoints(
            resultsForCalculation, 
            totalCompetitors, 
            eventToEdit.type
        );
        
        if (error) {
            throw new Error("B≈ÇƒÖd podczas przeliczania punkt√≥w");
        }
        
        // Zaktualizuj wyniki w historii
        eventToEdit.results = results;
        
        // Przelicz sumy punkt√≥w dla wszystkich zawodnik√≥w
        const newScores = {};
        currentState.competitors.forEach(competitor => {
            newScores[competitor] = 0;
        });
        
        currentState.eventHistory.forEach(event => {
            event.results.forEach(result => {
                if (newScores.hasOwnProperty(result.name)) {
                    newScores[result.name] += parseFloat(result.points) || 0;
                }
            });
        });
        
        // Zaktualizuj stan
        currentState.scores = newScores;
        restoreState(currentState);
        saveToUndoHistory(currentState);
        
        return true;
    } catch (error) {
        console.error("B≈ÇƒÖd przeliczania po edycji:", error);
        showNotification(`B≈ÇƒÖd przeliczania: ${error.message}`, "error");
        return false;
    }
}

// === EKSPORT DO PDF (PLACEHOLDER) ===
export async function exportToPdf() {
    showNotification("Funkcja eksportu do PDF bƒôdzie dostƒôpna w przysz≈Çej wersji.", "info");
    // Placeholder dla przysz≈Çej implementacji eksportu do PDF
}
